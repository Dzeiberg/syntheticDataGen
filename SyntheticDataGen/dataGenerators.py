# AUTOGENERATED! DO NOT EDIT! File to edit: 02_DataGenerators.ipynb (unless otherwise specified).

__all__ = ['DataGenerator', 'GaussianDG', 'UniformDG', 'NormalMixDG', 'MVNormalMixDG']

# Cell
import scipy.stats as ss
import numpy as np
from .mixture import Mixture

class DataGenerator:
    """
    Base data generator class
    Comprised of positive and negative class conditional distributions and a class prior
    """
    def __init__(self, positive_distribution, negative_distribution, classPrior):
        self.dist_p = positive_distribution
        self.dist_n = negative_distribution
        self.alpha = classPrior

    def data_pos(self, n):
        if isinstance(self.dist_p, Mixture):
            x, c = self.dist_p.rvsCompInfo(size=n)
            x = np.reshape(x, newshape=(n, -1))
        else:
            x = np.reshape(self.dist_p.rvs(size=(n,1)), newshape=(n, -1))
            c = np.ones((x.shape[0], 1))
        return x, c

    def data_neg(self, n):
        if isinstance(self.dist_n, Mixture):
            x, c = self.dist_n.rvsCompInfo(size=n)
            x = np.reshape(x, newshape=(n, -1))
        else:
            x = np.reshape(self.dist_n.rvs(size=(n, 1)), newshape=(n, -1))
            c = np.ones((x.shape[0], 1))
        return x, c

    def data_pos_compInfo(self, n):
        x, c = self.dist_p.rvsCompInfo(size=n)
        x = np.reshape(x, newshape=(n, -1))
        return x, c

    def data_neg_compInfo(self, n):
        x, c = self.dist_n.rvsCompInfo(size=n)
        x = np.reshape(x, newshape=(n, -1))
        return x, c

    def pu_data(self, n_p, n_u, alpha = None):
        if alpha == None:
            alpha = self.alpha
        x_p, c_p = self.data_pos(n_p)
        x_u, y_u, c_u,_,_,_,_ = self.pn_data(n_u, alpha)
        x_pu = np.concatenate((x_p, x_u), axis=0)
        y_pu = np.zeros([x_pu.shape[0], 1]).astype(bool)
        y_pu[np.arange(n_p), 0] = True
        y_pn = np.vstack((np.ones([n_p, 1]), y_u))
        c_pu = np.vstack((c_p, c_u))
        return x_pu, y_pu, y_pn, c_pu, x_p, x_u, y_u, c_p, c_u

    def pn_data(self, n, alpha=None):
        if alpha == None:
            alpha = self.alpha
        n_p = np.cast['int32'](np.floor(n * alpha))
        n_n = n - n_p
        x_p, c_p = self.data_pos(n_p)
        x_n, c_n = self.data_neg(n_n)
        y_p = np.ones((x_p.shape[0], 1)).astype(bool)
        y_n = np.zeros((x_n.shape[0], 1)).astype(bool)
        x = np.vstack((x_p, x_n))
        y = np.vstack((y_p, y_n))
        c = np.vstack((c_p, c_n))
        return x, y, c, x_p, x_n, c_p, c_n

    def dens_pos(self, x):
        return self.dist_p.pdf(x)

    def dens_neg(self, x):
        return self.dist_n.pdf(x)

    def dens_mix(self, x, alpha = None):
        if alpha == None:
            alpha = self.alpha
        return alpha * self.dens_pos(x) + (1 - alpha) * self.dens_neg(x)

    def pn_posterior(self, x, alpha = None):
        if alpha == None:
            alpha = self.alpha
        return alpha * self.dens_pos(x) / self.dens_mix(x, alpha)

    def pu_posterior(self, x, n_p, n_u, alpha=None):
        if alpha == None:
            alpha = self.alpha
        n_up = np.cast['int32'](np.floor(n_u * alpha))
        c1 = n_p / (n_u + n_p)
        c2 = (n_up + n_p) / (n_u + n_p)
        return c1 * self.dens_pos(x) / self.dens_mix(x, c2)

    def pn_posterior_sts(self, x, n_p, n_u, alpha = None):
        if alpha == None:
            alpha = self.alpha
        n_up = np.cast['int32'](np.floor(n_u * alpha))
        c = (n_up + n_p) / (self.n_u + self.n_p)
        return self.pn_posterior(x, c)

    def pn_posterior_cc(self, x):
        return self.pn_posterior(x, self.alpha)

    def pn_posterior_balanced(self, x):
        return self.pn_posterior(x, 0.5)

# Cell
class GaussianDG(DataGenerator):

    def __init__(self, mu, sig, alpha):
        dist_p = ss.norm(loc=0, scale=1)
        dist_n = ss.norm(loc=mu, scale=sig)
        super(GaussianDG, self).__init__(dist_p,dist_n,alpha)

# Cell
class UniformDG(DataGenerator):

    def __init__(self, aP, bP, aN, bN, alpha):
        dist_p = ss.uniform(loc=aP, scale=bP)
        dist_n = ss.uniform(loc=aN, scale=bN)
        super(UniformDG, self).__init__(dist_p,dist_n,alpha)

# Cell
class NormalMixDG(DataGenerator):

    def __init__(self, mu_pos, sig_pos, p_pos, mu_neg, sig_neg, p_neg, alpha):
        components_pos = [ss.norm(loc=mu, scale=sig) for (mu, sig) in zip(mu_pos, sig_pos)]
        components_neg = [ss.norm(loc=mu, scale=sig) for (mu, sig) in zip(mu_neg, sig_neg)]
        dist_p = Mixture(components_pos, p_pos)
        dist_n = Mixture(components_neg, p_neg)
        super(NormalMixDG, self).__init__(dist_p,dist_n,alpha)

# Cell
class MVNormalMixDG(DataGenerator):
    def __init__(self, mu_pos, sig_pos, p_pos, mu_neg, sig_neg, p_neg, alpha):
        self.components_pos = [ss.multivariate_normal(mean=mu, cov=sig) for (mu, sig) in zip(mu_pos, sig_pos)]
        self.components_neg = [ss.multivariate_normal(mean=mu, cov=sig) for (mu, sig) in zip(mu_neg, sig_neg)]
        dist_p = Mixture(self.components_pos, p_pos)
        dist_n = Mixture(self.components_neg, p_neg)
        super(MVNormalMixDG, self).__init__(dist_p,dist_n,alpha)