# AUTOGENERATED! DO NOT EDIT! File to edit: 05_Dataset.ipynb (unless otherwise specified).

__all__ = ['GaussianMixtureDataGenerator', 'createMixture', 'pointsBetween', 'mycdf', 'clustersConflict',
           'jitterMixtures', 'getConflictingPairs', 'jitterComponents', 'generateParams']

# Cell
from .randomParameters import NormalMixPNParameters2 as NMixPar

def GaussianMixtureDataGenerator(dim, n_comps, aucpn_range,irreducibility_params,timeoutMins=1,nTimeouts=5):
    #setting the thrid entry of irreducibility_params to False enforces pairwise mutual irreducibility
    #setting the thrid entry of irreducibility_params to True enforces the strong irreducibility.
    #The second entry of irreducibility_params is the the posterior threshold for irreducibility.
    #The first argument is the proportion of points that should high enough posterior.
    #Using 0.01 and 0.9 is easier to satisfy then 0.05 and 0.95. You may play with this,
    # but note that the stronger irreducibility criteria, the more difficult it is to be satisfied
    # and you might end up in infinite loop since no parameters could be founs to satisfy bo the
    # itrreducibility and auc criteria.
    NMix = NMixPar(dim, n_comps,aucpn_range, irreducibility_params,timeoutMins=timeoutMins,nTimeouts=nTimeouts)
#     NMix.perturb2SatisfyMetrics()
#     NMix.updateDataGenerator()
    dg = NMix.dg
    return NMix, dg

# Cell
from .mixture import Mixture

def createMixture(NMix,cluster_num):
    gamma = NMix.alpha * NMix.p_pos[cluster_num] + (1 - NMix.alpha) * NMix.p_neg[cluster_num]
    eta = NMix.alpha * NMix.p_pos[cluster_num] / gamma
    m = Mixture((NMix.dg.dist_p.comps[cluster_num],
                 NMix.dg.dist_n.comps[cluster_num]),np.array([eta,1-eta]))
    return m

# Cell
def pointsBetween(NMix,i,j):
    mixI = createMixture(NMix,i)
    mI = np.dot(mixI.mixProp,[c.mean for c in mixI.comps])
    vec = NMix.vecBetweenPair(i,j)
    for scale in np.arange(0,1,.01):
        yield mI - vec * scale

# Cell
import numpy as np
def mycdf(mixture,x,n_samples=10000):
    mixtureMean = mixture.mean
    d = np.linalg.norm(mixtureMean - x)**2
    dists = np.linalg.norm(mixture.rvs(n_samples) - mixtureMean,axis=-1)**2
    return (dists <= d).sum() / n_samples

# Cell
def clustersConflict(NMix,i,j):
    mixI = createMixture(NMix,i)
    mixJ = createMixture(NMix,j)
    for x in pointsBetween(NMix,i,j):
        if (1 - mycdf(mixI,x)) > .05 and (1-mycdf(mixJ,x)) > .05:
            return True
    return False

# Cell
from itertools import combinations
import scipy.stats as ss

def jitterMixtures(NMix,i,j):
    jitterFactor = ss.gamma.rvs(2)
    print(i,j,jitterFactor)
    NMix.dg.components_pos[i].mean += jitterFactor
    NMix.dg.components_neg[i].mean += jitterFactor
    NMix.dg.components_pos[j].mean -= jitterFactor
    NMix.dg.components_neg[j].mean -= jitterFactor
    return NMix

def getConflictingPairs(NMix):
    return [(i,j) for i,j in combinations(np.arange(NMix.nComps),2) if clustersConflict(NMix,i,j)]

def jitterComponents(NMix):
    pairs = getConflictingPairs(NMix)
    while len(pairs):
        for i,j in pairs:
            while clustersConflict(NMix,i,j):
                NMix = jitterMixtures(NMix,i,j)
        pairs = getConflictingPairs(NMix)
    return NMix

def generateParams(n_clusters,dim,aucRange,irreducibility_params=[.01,0.9,False],timeoutMins=1,nTimeouts=5):
    NMix,dg = GaussianMixtureDataGenerator(dim,n_clusters,aucRange,irreducibility_params,timeoutMins=timeoutMins,nTimeouts=nTimeouts)
    NMix = jitterComponents(NMix)
    return NMix